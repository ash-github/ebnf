=1
#include <cassert>
#include <cstdio>
#include <exception>
#include <initializer_list>
#include <utility>
#include "parser.inc"

int syntax_errors;

class SyntaxError: std::runtime_error
{
public:
	SyntaxError(): runtime_error("syntax error") {}
};

constexpr size_t log2_r(size_t n, size_t a)
{
	return n == 1 ? a : log2_r(n>>1, a+1);
}
constexpr size_t log2(size_t n)
{
	return log2_r(n, 0);
}

template <size_t N>
class bitset {
	static const size_t unit = sizeof(long)*8;
	static const size_t lunit = log2(unit);
	static const size_t n = (N+unit-1)/unit;
	unsigned long data[n];
public:
	bitset(): data() {}
	bitset(std::initializer_list<int> l): data()
	{
		for (auto index: l)
			set(index);
	}
	bool get(int index) const
	{
		return data[index>>lunit] & (1<<(index&(unit-1)));
	}
	void set(int index)
	{
		data[index>>lunit] |= (1<<(index&(unit-1)));
	}
	void clear(int index)
	{
		data[index>>lunit] &= ~(1<<(index&(unit-1)));
	}
	bitset<N> operator|(const bitset<N> &that) const
	{
		bitset<N> result(*this);
		for (size_t i=0; i<n; i++)
			result.data[i] |= that.data[i];
		return result;
	}
};
=2
static bool check(int s, const set &t, const set &f)
{
	if (sym == s)
		return true;
	syntax_errors++;
	fprintf(stderr, "%d:%d: syntax error at ‘%.*s’\n",
		lineno, colno, toklen, tokstart);
	for (;;) {
		if (t.get(sym)) return false;
		if (f.get(sym)) throw SyntaxError();
		fprintf(stderr, "%d:%d: [skipping ‘%.*s’]\n",
			lineno, colno, toklen, tokstart);
		getsym();
	}
}
